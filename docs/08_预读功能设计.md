# 预读功能设计

## 概述

预读（Prefetch）是数据库系统中重要的性能优化技术，通过预测性地将可能被访问的数据页面提前加载到内存中，减少I/O等待时间，提升查询性能。

## 架构设计

```
查询执行器
    ↓
预读配置管理器 (PrefetchConfigManager)
    ↓
异步缓冲池管理器 (AsyncBufferPoolManager)
    ↓
异步磁盘管理器 (AsyncDiskManager)
    ↓
物理存储
```

## 核心组件

### 1. 异步缓冲池管理器 (AsyncBufferPoolManager)

#### 基础预读功能
- `PrefetchPage(int page_id)` - 单页面预读
- `PrefetchPages(const std::vector<int>& page_ids)` - 批量页面预读

#### 智能预读功能
- `PrefetchSequential(int start_page_id, int count)` - 顺序预读
- `PrefetchRange(int start_page_id, int end_page_id)` - 范围预读
- `SetPrefetchConfig(size_t max_prefetch_pages, size_t prefetch_threshold)` - 配置预读参数

#### 性能监控
```cpp
struct PrefetchStats {
    size_t total_prefetch_requests = 0;
    size_t successful_prefetches = 0;
    size_t cache_hits_from_prefetch = 0;
    double prefetch_hit_rate = 0.0;
};
```

### 2. 预读配置管理器 (PrefetchConfigManager)

#### 预读策略
```cpp
enum class PrefetchStrategy {
    NONE,           // 不预读
    SEQUENTIAL,     // 顺序预读
    RANDOM,         // 随机预读
    ADAPTIVE        // 自适应预读
};
```

#### 配置管理
- 全局配置和表级别配置
- 动态调整预读参数
- 基于访问模式的自适应决策

#### 性能统计
```cpp
struct PrefetchPerformanceStats {
    size_t total_prefetch_requests = 0;
    size_t successful_prefetches = 0;
    size_t cache_hits_from_prefetch = 0;
    size_t wasted_prefetches = 0;
    double prefetch_hit_rate = 0.0;
    double prefetch_efficiency = 0.0;
    std::chrono::milliseconds total_prefetch_time{0};
    std::chrono::milliseconds avg_prefetch_time{0};
};
```

### 3. B+树索引预读优化

#### 范围查询预读
- 在`FindRange()`操作中自动预读相关叶子节点
- 基于叶子节点链表结构进行连续预读
- 可配置的预读页面数量

#### 配置接口
```cpp
void EnablePrefetch(bool enable);
void SetPrefetchConfig(size_t max_prefetch_pages);
```

## 预读策略详解

### 1. 顺序预读 (Sequential Prefetch)
- **适用场景**: 顺序扫描、范围查询
- **实现方式**: 预读连续的页面序列
- **优势**: 对顺序访问模式效果显著

### 2. 自适应预读 (Adaptive Prefetch)
- **适用场景**: 混合访问模式
- **实现方式**: 基于历史访问模式动态调整
- **决策因素**:
  - 访问模式顺序性得分
  - 预读命中率
  - 预读效率

### 3. 范围预读 (Range Prefetch)
- **适用场景**: 范围查询、B+树索引扫描
- **实现方式**: 预读指定范围内的所有页面
- **优势**: 适合已知访问范围的情况

## 性能优化特性

### 1. 异步I/O
- 使用`std::async`实现非阻塞预读
- 工作线程池处理I/O任务
- 避免阻塞主查询线程

### 2. 智能缓存管理
- 检查页面是否已在缓存中，避免重复预读
- 基于LRU策略的页面淘汰
- 引用计数管理页面生命周期

### 3. 批量操作优化
- 批量预读减少系统调用开销
- 任务队列批量处理I/O请求
- 减少线程切换成本

## 使用示例

### 基础预读使用
```cpp
AsyncBufferPoolManager buffer_pool(100, &disk_manager);

// 配置预读参数
buffer_pool.SetPrefetchConfig(10, 3);

// 顺序预读
buffer_pool.PrefetchSequential(1, 5);

// 范围预读
buffer_pool.PrefetchRange(10, 15);

// 获取统计信息
auto stats = buffer_pool.GetPrefetchStats();
```

### 自适应预读配置
```cpp
auto& config_manager = PrefetchConfigManager::GetInstance();

PrefetchConfig config;
config.strategy = PrefetchStrategy::ADAPTIVE;
config.max_prefetch_pages = 8;
config.prefetch_aggressiveness = 0.6;
config_manager.SetGlobalConfig(config);

// 基于访问模式决策
std::vector<int> recent_accesses = {1, 2, 3, 4, 5};
bool should_prefetch = config_manager.ShouldPrefetch("table", 6, recent_accesses);
size_t prefetch_count = config_manager.GetOptimalPrefetchCount("table", recent_accesses);
```

### B+树索引预读
```cpp
BPlusTreeIndex index(&bpm, "table", "column", 0);

// 启用预读
index.EnablePrefetch(true);
index.SetPrefetchConfig(5);

// 范围查询会自动使用预读
auto results = index.FindRange(start_key, end_key);
```

## 性能监控

### 关键指标
1. **预读命中率**: 预读页面被实际访问的比例
2. **预读效率**: 有效预读占总预读的比例
3. **平均预读时间**: 预读操作的平均耗时
4. **预读浪费率**: 预读但未使用页面的比例

### 监控接口
```cpp
// 获取全局统计
auto global_stats = config_manager.GetStats();

// 获取表级别统计
auto table_stats = config_manager.GetStats("table_name");

// 重置统计
config_manager.ResetStats("table_name");
```

## 配置建议

### 1. 预读页面数量
- **小表**: 2-5页
- **中表**: 5-10页
- **大表**: 10-20页

### 2. 预读阈值
- **顺序访问**: 3-5
- **随机访问**: 1-3
- **混合访问**: 2-4

### 3. 自适应参数
- **激进程度**: 0.5-0.8
- **调整频率**: 每100次访问
- **历史窗口**: 最近20次访问

## 性能预期

### 顺序扫描优化
- **性能提升**: 20-40%
- **适用场景**: 全表扫描、范围查询

### 索引扫描优化
- **性能提升**: 15-30%
- **适用场景**: B+树范围查询

### 混合工作负载
- **性能提升**: 10-25%
- **适用场景**: OLTP和OLAP混合负载

## 注意事项

### 1. 内存使用
- 预读会增加内存使用量
- 需要合理配置预读页面数量
- 监控内存使用情况

### 2. I/O负载
- 预读会增加I/O负载
- 在I/O密集型场景下需要谨慎使用
- 考虑磁盘I/O能力

### 3. 缓存污染
- 过度预读可能导致缓存污染
- 需要基于访问模式调整预读策略
- 监控缓存命中率变化

## 未来改进方向

### 1. 机器学习优化
- 基于历史访问模式训练预读模型
- 动态调整预读策略参数
- 预测用户查询模式

### 2. 多级预读
- 实现页面级和块级预读
- 支持不同粒度的预读策略
- 优化预读层次结构

### 3. 分布式预读
- 支持跨节点的预读协调
- 实现分布式缓存一致性
- 优化网络I/O预读

## 总结

本系统实现了完整的预读功能，包括：

1. **基础预读**: 支持单页面和批量页面预读
2. **智能预读**: 提供顺序、范围、自适应等多种预读策略
3. **性能监控**: 详细的预读性能统计和监控
4. **配置管理**: 灵活的预读配置和参数调整
5. **索引集成**: B+树索引的预读优化

这些功能能够显著提升数据库系统的查询性能，特别是在顺序扫描和范围查询场景下。通过合理的配置和监控，可以在不同工作负载下获得最佳的性能表现。
